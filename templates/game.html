{% extends "base.html" %}

{% block head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/game.css') }}">
{% endblock %}

{% block body %}
<div class="game-container">
    <!-- Info Container f√ºr Runde, Timer und Guthaben in einer Reihe -->
    <div class="top-info-row">
        <!-- Timer als Kreis (links) -->
        <div class="info-section timer-section">
            <div class="timer-circle">
                <svg class="progress-ring" viewBox="0 0 100 100">
                    <circle class="progress-ring-background" cx="50" cy="50" r="45" stroke-width="10"></circle>
                    <circle class="progress-ring-circle" cx="50" cy="50" r="45" stroke-width="10"></circle>
                </svg>
                <div class="timer-content">
                    <div class="timer-time" id="timer">--</div>
                </div>
            </div>
        </div>
        
        <!-- Runden-Anzeige (mittig) -->
        <div class="info-section round-section">
            <div class="round-number"><span id="currentRound">Runde {{ current_round }}</span></div>
        </div>
        
        <!-- Guthaben mit M√ºnze (rechts) -->
        <div class="info-section balance-section">
            <div class="balance-display">
                <div class="coin-stack">
                    <div class="coin coin-1">ü™ô</div>
                    <div class="coin coin-2">ü™ô</div>
                    <div class="coin coin-3">ü™ô</div>
                </div>
                <div class="balance-amount" id="currentBalance">{{ "%.2f"|format(player.coins) }}</div>
            </div>
        </div>
    </div>
    
    <!-- Gruppeninformation -->
    {% if player_group %}
    <div class="group-info">
        <h3>üë• Deine Gruppe {{ player_group.group_number }}</h3>
        <div class="group-members">
            {% for member in player_group.members %}
            <div class="member-badge {% if member == player.name %}you{% endif %}">
                {{ member }}{% if member == player.name %} (Du){% endif %}
            </div>
            {% endfor %}
        </div>
    </div>
    {% endif %}
    
    <!-- Einzahlungsbereich -->
    <div class="contribution-section">
        <h3 style="text-align: center; margin-bottom: 20px;">
            üí∞ Wie viel m√∂chtest du einzahlen?
        </h3>
        
        <div class="contribution-options" id="coinOptions">
            <!-- Wird per JavaScript generiert -->
        </div>
        
        <button class="btn submit-button" id="submitBtn" disabled>
            Beitrag einreichen
        </button>
        
        <div style="text-align: center; margin-top: 15px; color: #aaa; font-size: 14px;">
            W√§hle einen Betrag zwischen 0 und <span id="maxAmount">{{ room.settings.max_contribution }}</span> Coins
        </div>
    </div>
</div>

<!-- Warte-Overlay -->
<div class="waiting-overlay" id="waitingOverlay">
    <div class="waiting-content">
        <h2>‚è≥ Warte auf andere Spieler</h2>
        <div class="spinner"></div>
        <p>Du hast deinen Beitrag eingereicht</p>
        <div class="submitted-count" id="submittedCount">
            <span id="submittedNumber">0</span> von <span id="totalPlayers">{{ room.players|length }}</span> Spielern haben eingereicht
        </div>
    </div>
</div>

<div id="game-data" 
     data-round-duration="{{ room.settings.round_duration }}"
     data-max-contribution="{{ room.settings.max_contribution }}"
     data-initial-balance="{{ player.coins }}"
     data-total-players="{{ room.players|length }}"
     style="display: none;">
</div>
{% endblock %}

{% block scripts %}
<script>
    let selectedContribution = null;
    let serverTimeLeft = null;
    let localCountdownInterval = null;
    let hasSubmitted = false;
    let roundDuration = null;
    let progressRing = null;

    document.addEventListener('DOMContentLoaded', function() {
        const gameData = document.getElementById('game-data');
        const maxContribution = parseInt(gameData.dataset.maxContribution);
        const initialBalance = parseFloat(gameData.dataset.initialBalance);
        const totalPlayers = parseInt(gameData.dataset.totalPlayers);
        roundDuration = parseInt(gameData.dataset.roundDuration);

        // Progress Ring initialisieren
        progressRing = document.querySelector('.progress-ring-circle');
        if (progressRing) {
            const radius = 45; // Radius aus dem SVG (r-Attribut)
            const circumference = radius * 2 * Math.PI;
            
            progressRing.style.strokeDasharray = `${circumference} ${circumference}`;
            progressRing.style.strokeDashoffset = circumference;
        }

        // UI initialisieren
        generateCoinOptions(maxContribution, initialBalance);
        const maxAmountElement = document.getElementById('maxAmount');
        if (maxAmountElement) maxAmountElement.textContent = maxContribution;

        const totalPlayersElement = document.getElementById('totalPlayers');
        if (totalPlayersElement) totalPlayersElement.textContent = totalPlayers;

        // Verhindere Mehrfach-Submits
        hasSubmitted = false;

        // Raum betreten (wichtig vor m√∂glichen Auto-Submits)
        socket.emit('join_game_room', { room_id: currentRoomId });

        // Lade den aktuellen Timer-Status vom Server (authoritative)
        loadTimerStatus();

        // Submit Button Event
        const submitBtn = document.getElementById('submitBtn');
        if (submitBtn) {
            submitBtn.addEventListener('click', submitContribution);
        }
    });

    function generateCoinOptions(maxAmount, currentBalance) {
        const container = document.getElementById('coinOptions');
        if (!container) return;

        container.innerHTML = '';

        for (let i = 0; i <= maxAmount; i++) {
            const option = document.createElement('div');
            option.className = 'coin-option';
            option.textContent = i;
            option.dataset.value = i;

            if (i > currentBalance) {
                option.classList.add('disabled');
            } else {
                option.addEventListener('click', function() {
                    if (hasSubmitted) return; // nach Abgabe keine Auswahl mehr
                    selectContribution(i, option);
                });
            }

            container.appendChild(option);
        }
    }

    function selectContribution(amount, element) {
        selectedContribution = amount;

        document.querySelectorAll('.coin-option').forEach(opt => {
            opt.classList.remove('selected');
        });

        element.classList.add('selected');

        const submitBtn = document.getElementById('submitBtn');
        if (submitBtn) submitBtn.disabled = false;
    }

    function setProgress(percent) {
        if (!progressRing) return;
        
        const radius = progressRing.r.baseVal.value;
        const circumference = radius * 2 * Math.PI;
        const offset = circumference - (percent / 100) * circumference;
        
        progressRing.style.strokeDashoffset = offset;
    }

    function updateTimerDisplay() {
        const timerElement = document.getElementById('timer');
        if (!timerElement) return;
        timerElement.textContent = (serverTimeLeft !== null) ? serverTimeLeft : '--';
        
        // Progressbar aktualisieren
        if (roundDuration && serverTimeLeft !== null) {
            const progressPercent = (serverTimeLeft / roundDuration) * 100;
            setProgress(progressPercent);
        }
        
        updateTimerWarnings();
    }

    function updateTimerWarnings() {
        const timerElement = document.getElementById('timer');
        const progressRing = document.querySelector('.progress-ring-circle');
        if (!timerElement || !progressRing) return;

        // Entferne alle Farbklassen
        timerElement.classList.remove('warning', 'danger', 'critical');
        progressRing.classList.remove('warning', 'danger', 'critical');

        if (serverTimeLeft <= 5) {
            timerElement.classList.add('critical');
            progressRing.classList.add('critical');
        } else if (serverTimeLeft <= 15) {
            timerElement.classList.add('danger');
            progressRing.classList.add('danger');
        } else if (serverTimeLeft <= 30) {
            timerElement.classList.add('warning');
            progressRing.classList.add('warning');
        }
    }

    function loadTimerStatus() {
        fetch(`/api/room/${currentRoomId}/dashboard_status`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    serverTimeLeft = parseInt(data.time_left);
                    updateTimerDisplay();

                    console.log('DEBUG: Geladener Timer-Status:', serverTimeLeft, 'Sekunden');

                    // Wenn der Server sagt: Zeit ist 0 und noch nicht abgegeben => handle expiration
                    if (serverTimeLeft <= 0) {
                        // kurze Verz√∂gerung, damit join_game_room zuvor verarbeitet wird
                        setTimeout(() => {
                            handleTimeExpiredOnce();
                        }, 100); 
                    } else {
                        // Starte lokalen Countdown (falls noch nicht aktiv)
                        startLocalCountdown();
                    }
                }
            })
            .catch(error => {
                console.error('Fehler beim Laden des Timer-Status:', error);
            });
    }

    function startLocalCountdown() {
        // stoppe evtl. existierenden Intervall
        stopLocalCountdown();

        localCountdownInterval = setInterval(() => {
            if (serverTimeLeft === null) return;
            if (serverTimeLeft <= 0) {
                stopLocalCountdown();
                handleTimeExpiredOnce();
                return;
            }
            serverTimeLeft -= 1;
            updateTimerDisplay();
        }, 1000);
    }

    function stopLocalCountdown() {
        if (localCountdownInterval) {
            clearInterval(localCountdownInterval);
            localCountdownInterval = null;
        }
    }

    function handleTimeExpiredOnce() {
        // Wenn schon abgegeben, nichts tun
        if (hasSubmitted) return;

        // Falls der Spieler noch nichts gew√§hlt hat, setze 0 und reiche ein
        if (selectedContribution === null) {
            console.log('DEBUG: Zeit abgelaufen (client side), reiche 0 Coins ein');
            selectedContribution = 0;
        }
        submitContribution();
    }

    function submitContribution() {
        if (hasSubmitted) {
            console.log('DEBUG: bereits eingereicht, Ignoriere weiteren Submit');
            return;
        }
        if (selectedContribution === null) {
            showNotification('Bitte w√§hle einen Betrag aus', 'error');
            return;
        }

        // UI: disable interaktion
        disableInteractionAfterSubmit();

        // Markiere als abgegeben (verhindert doppelte submits)
        hasSubmitted = true;

        // Beitrag an Server senden
        socket.emit('submit_contribution', {
            contribution: selectedContribution
        });
    }

    function disableInteractionAfterSubmit() {
        // Disable Button und Optionen, zeige Overlay
        const submitBtn = document.getElementById('submitBtn');
        if (submitBtn) submitBtn.disabled = true;

        document.querySelectorAll('.coin-option').forEach(opt => {
            opt.classList.add('disabled');
            opt.removeEventListener('click', () => {});
        });

        const waitingOverlay = document.getElementById('waitingOverlay');
        if (waitingOverlay) waitingOverlay.style.display = 'flex';
    }

    // WebSocket Events f√ºr game.html
    socket.on('contribution_submitted', function(data) {
        const submittedNumber = document.getElementById('submittedNumber');
        const totalPlayersEl = document.getElementById('totalPlayers');

        if (submittedNumber) {
            submittedNumber.textContent = data.submitted_count;
        }
        if (totalPlayersEl) {
            totalPlayersEl.textContent = data.total_players;
        }
    });

    socket.on('game_timer_update', function(data) {
        // Server ist authoritative
        serverTimeLeft = parseInt(data.time_left);
        updateTimerDisplay();

        // Wenn Server 0 sendet: local countdown stoppen & auto-submit falls n√∂tig
        if (serverTimeLeft <= 0) {
            stopLocalCountdown();
            handleTimeExpiredOnce();
        } else {
            // starte/aktualisiere lokalen Countdown
            startLocalCountdown();
        }
    });

    socket.on('game_time_out', function() {
        console.log('DEBUG: game_time_out received');
        showNotification('Zeit abgelaufen! Beitr√§ge werden automatisch eingereicht.', 'warning');

        // Server hat Timeout ‚Äì sichere clientseitige Auto-Submit
        stopLocalCountdown();
        handleTimeExpiredOnce();
    });

    socket.on('round_finished', function(data) {
        console.log('DEBUG: round_finished received, redirecting to round results');
        showNotification('Runde beendet! Zeige Ergebnisse...', 'success');
        // kleine Verz√∂gerung damit UI Meldung wahrnehmbar ist
        setTimeout(() => {
            window.location.href = `/round_results/${data.room_id}`;
        }, 800);
    });

    socket.on('redirect_to_results', function(data) {
        console.log('DEBUG: redirect_to_results received');
        showNotification('Runde beendet! Zeige Ergebnisse...', 'success');
        setTimeout(() => {
            window.location.href = `/round_results/${data.room_id}`;
        }, 600);
    });

    socket.on('game_finished', function(data) {
        showNotification('Spiel beendet! Zeige Auswertung...', 'success');
        setTimeout(() => {
            window.location.href = `/evaluation/${data.room_id}`;
        }, 800);
    });
</script>
{% endblock %}