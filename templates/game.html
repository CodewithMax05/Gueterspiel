{% extends "base.html" %}

{% block head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/game.css') }}">
{% endblock %}

{% block body %}
<div class="game-container">
    <!-- Info Container f√ºr Runde, Timer und Guthaben in einer Reihe -->
    <div class="top-info-row">
        <!-- Timer als Kreis (links) -->
        <div class="info-section timer-section">
            <div class="timer-circle">
                <svg class="progress-ring" viewBox="0 0 100 100">
                    <circle class="progress-ring-background" cx="50" cy="50" r="45" stroke-width="10"></circle>
                    <circle class="progress-ring-circle" cx="50" cy="50" r="45" stroke-width="10"></circle>
                </svg>
                <div class="timer-content">
                    <div class="timer-time" id="timer">--</div>
                </div>
            </div>
        </div>
        
        <!-- Runden-Anzeige (mittig) -->
        <div class="info-section round-section">
            <div class="round-number"><span id="currentRound">Runde {{ current_round }}</span></div>
        </div>
        
        <!-- Guthaben mit M√ºnze (rechts) -->
        <div class="info-section balance-section">
            <div class="balance-display">
                <div class="coin-stack">
                    <div class="coin coin-1">ü™ô</div>
                    <div class="coin coin-2">ü™ô</div>
                    <div class="coin coin-3">ü™ô</div>
                </div>
                <div class="balance-amount" id="currentBalance">{{ "%.2f"|format(player.coins) }}</div>
            </div>
        </div>
    </div>
    
    <!-- Gruppeninformation -->
    {% if player_group and not room.incognito_mode %}
    <div class="group-info">
        <h3 class="group-title">üë• Deine Gruppe {{ player_group.group_number }}</h3>
        <div class="group-members">
            {% for member in player_group.members %}
            <div class="member-badge {% if member == player.name %}you{% endif %}">
                {{ member }}{% if member == player.name %} (Du){% endif %}
            </div>
            {% endfor %}
        </div>
    </div>
    {% elif player_group and room.incognito_mode %}
    <div class="group-info">
        <h3 class="group-title">üë• Deine Gruppe</h3>
        <div class="group-members">
            <div class="member-badge you">
                {{ player.name }} (Du)
            </div>
            {% for i in range(player_group.members|length - 1) %}
            <div class="member-badge anonymous">
                Spieler {{ i + 2 }}
            </div>
            {% endfor %}
        </div>
        <p class="incognito-hint">
            üí° Inkognito-Modus: Sie sehen nur Ihren eigenen Namen
        </p>
    </div>
    {% endif %}
    
    <!-- Einzahlungsbereich -->
    <div class="contribution-section">
        <h3 class="contribution-title">
            üí∞ Wie viel m√∂chtest du einzahlen?
        </h3>
        
        <div class="contribution-options" id="coinOptions">
            <!-- Wird per JavaScript generiert -->
        </div>
        
        <button class="btn submit-button" id="submitBtn" disabled>
            Beitrag einreichen
        </button>
        
        <div class="contribution-hint">
            W√§hle einen Betrag zwischen 0 und deinem aktuellen Guthaben (<span id="currentBalanceText">{{ "%.2f"|format(player.coins) }}</span> Coins)
        </div>
    </div>
</div>

<!-- Warte-Overlay -->
<div class="waiting-overlay" id="waitingOverlay">
    <div class="waiting-content">
        <h2>‚è≥ Warte auf andere Spieler</h2>
        <div class="spinner"></div>
        <p>Du hast deinen Beitrag eingereicht</p>
        <div class="submitted-count" id="submittedCount">
            <span id="submittedNumber">0</span> von <span id="totalPlayers">{{ room.players|length }}</span> Spielern haben eingereicht
        </div>
    </div>
</div>

<div id="game-data" 
     data-round-duration="{{ room.settings.round_duration }}"
     data-initial-balance="{{ player.coins }}"
     data-total-players="{{ room.players|length }}"
     class="hidden">
</div>
{% endblock %}

{% block scripts %}
<script>
    let selectedContribution = null;
    let serverTimeLeft = null;
    let localCountdownInterval = null;
    let hasSubmitted = false;
    let roundDuration = null;
    let progressRing = null;

    document.addEventListener('DOMContentLoaded', function() {
        const gameData = document.getElementById('game-data');
        const initialBalance = parseFloat(gameData.dataset.initialBalance);
        const totalPlayers = parseInt(gameData.dataset.totalPlayers);
        roundDuration = parseInt(gameData.dataset.roundDuration);

        // Progress Ring initialisieren
        progressRing = document.querySelector('.progress-ring-circle');
        if (progressRing) {
            const radius = 45; // Radius aus dem SVG (r-Attribut)
            const circumference = radius * 2 * Math.PI;
            
            progressRing.style.strokeDasharray = `${circumference} ${circumference}`;
            progressRing.style.strokeDashoffset = circumference;
        }

        // UI initialisieren
        generateCoinOptions(initialBalance);
        const currentBalanceText = document.getElementById('currentBalanceText');
        if (currentBalanceText) currentBalanceText.textContent = initialBalance.toFixed(2);

        const totalPlayersElement = document.getElementById('totalPlayers');
        if (totalPlayersElement) totalPlayersElement.textContent = totalPlayers;

        // Verhindere Mehrfach-Submits
        hasSubmitted = false;

        // Raum betreten (wichtig vor m√∂glichen Auto-Submits)
        socket.emit('join_game_room', { room_id: currentRoomId });

        // Submit Button Event
        const submitBtn = document.getElementById('submitBtn');
        if (submitBtn) {
            submitBtn.addEventListener('click', submitContribution);
        }
    });

    function generateCoinOptions(currentBalance) {
        const container = document.getElementById('coinOptions');
        if (!container) return;

        container.innerHTML = '';

        // Maximum ist jetzt das aktuelle Guthaben (abgerundet)
        const maxAmount = Math.floor(currentBalance);

        for (let i = 0; i <= maxAmount; i++) {
            const option = document.createElement('div');
            option.className = 'coin-option';
            option.textContent = i;
            option.dataset.value = i;

            // Alle Optionen sind verf√ºgbar, da wir nur bis zum Guthaben gehen
            option.addEventListener('click', function() {
                if (hasSubmitted) return;
                selectContribution(i, option);
            });

            container.appendChild(option);
        }
    }

    function selectContribution(amount, element) {
        selectedContribution = amount;

        document.querySelectorAll('.coin-option').forEach(opt => {
            opt.classList.remove('selected');
        });

        element.classList.add('selected');

        const submitBtn = document.getElementById('submitBtn');
        if (submitBtn) submitBtn.disabled = false;
    }

    function setProgress(percent) {
        if (!progressRing) return;
        
        const radius = progressRing.r.baseVal.value;
        const circumference = radius * 2 * Math.PI;
        const offset = circumference - (percent / 100) * circumference;
        
        progressRing.style.strokeDashoffset = offset;
    }

    function updateTimerDisplay() {
        const timerElement = document.getElementById('timer');
        if (!timerElement) return;
        timerElement.textContent = (serverTimeLeft !== null) ? serverTimeLeft : '--';
        
        // Progressbar aktualisieren
        if (roundDuration && serverTimeLeft !== null) {
            const progressPercent = (serverTimeLeft / roundDuration) * 100;
            setProgress(progressPercent);
        }
        
        updateTimerWarnings();
    }

    function updateTimerWarnings() {
        const timerElement = document.getElementById('timer');
        const progressRing = document.querySelector('.progress-ring-circle');
        if (!timerElement || !progressRing) return;

        // Entferne alle Farbklassen
        timerElement.classList.remove('warning', 'danger', 'critical');
        progressRing.classList.remove('warning', 'danger', 'critical');

        if (serverTimeLeft <= 5) {
            timerElement.classList.add('critical');
            progressRing.classList.add('critical');
        } else if (serverTimeLeft <= 15) {
            timerElement.classList.add('danger');
            progressRing.classList.add('danger');
        } else if (serverTimeLeft <= 30) {
            timerElement.classList.add('warning');
            progressRing.classList.add('warning');
        }
    }

    function loadTimerStatus() {
        fetch(`/api/room/${currentRoomId}/dashboard_status`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    serverTimeLeft = parseInt(data.time_left);
                    updateTimerDisplay();

                    console.log('DEBUG: Geladener Timer-Status:', serverTimeLeft, 'Sekunden');

                    // Wenn der Server sagt: Zeit ist 0 und noch nicht abgegeben => handle expiration
                    if (serverTimeLeft <= 0) {
                        // kurze Verz√∂gerung, damit join_game_room zuvor verarbeitet wird
                        setTimeout(() => {
                            handleTimeExpiredOnce();
                        }, 100); 
                    } else {
                        // Starte lokalen Countdown (falls noch nicht aktiv)
                        startLocalCountdown();
                    }
                }
            })
            .catch(error => {
                console.error('Fehler beim Laden des Timer-Status:', error);
            });
    }

    function startLocalCountdown() {
        // stoppe evtl. existierenden Intervall
        stopLocalCountdown();

        // Speichere den Startwert f√ºr pr√§zisere Berechnung
        const countdownStartTime = Date.now();
        const countdownStartValue = serverTimeLeft;

        localCountdownInterval = setInterval(() => {
            if (serverTimeLeft === null) return;
            
            // Berechne wie viel Zeit seit Start des Countdowns vergangen ist
            const elapsedSinceStart = Math.floor((Date.now() - countdownStartTime) / 1000);
            serverTimeLeft = Math.max(0, countdownStartValue - elapsedSinceStart);
            
            updateTimerDisplay();
            
            if (serverTimeLeft <= 0) {
                stopLocalCountdown();
                handleTimeExpiredOnce();
                return;
            }
        }, 1000);
    }

    function stopLocalCountdown() {
        if (localCountdownInterval) {
            clearInterval(localCountdownInterval);
            localCountdownInterval = null;
        }
    }

    function handleTimeExpiredOnce() {
        // Wenn schon abgegeben, nichts tun
        if (hasSubmitted) return;

        // Falls der Spieler noch nichts gew√§hlt hat, setze 0 und reiche ein
        if (selectedContribution === null) {
            console.log('DEBUG: Zeit abgelaufen (client side), reiche 0 Coins ein');
            selectedContribution = 0;
        }
        submitContribution();
    }

    function submitContribution() {
        if (hasSubmitted) {
            console.log('DEBUG: bereits eingereicht, Ignoriere weiteren Submit');
            return;
        }
        if (selectedContribution === null) {
            showNotification('Bitte w√§hle einen Betrag aus', 'error');
            return;
        }

        // UI: disable interaktion
        disableInteractionAfterSubmit();

        // Markiere als abgegeben (verhindert doppelte submits)
        hasSubmitted = true;

        // Beitrag an Server senden
        socket.emit('submit_contribution', {
            contribution: selectedContribution
        });
    }

    function disableInteractionAfterSubmit() {
        // Disable Button und Optionen, zeige Overlay
        const submitBtn = document.getElementById('submitBtn');
        if (submitBtn) submitBtn.disabled = true;

        document.querySelectorAll('.coin-option').forEach(opt => {
            opt.classList.add('disabled');
            opt.removeEventListener('click', () => {});
        });

        const waitingOverlay = document.getElementById('waitingOverlay');
        if (waitingOverlay) waitingOverlay.style.display = 'flex';
    }

    // WebSocket Events f√ºr game.html
    socket.on('room_state_update', function(data) {
        console.log('DEBUG: room_state_update empfangen:', data);
        
        // Timer-Status verarbeiten
        if (data.timer) {
            if (data.timer.start_time && data.timer.duration) {
                // Berechne aktuelle Zeit basierend auf start_time
                const nowMs = Date.now();
                const elapsedSec = Math.floor((nowMs - Number(data.timer.start_time)) / 1000);
                serverTimeLeft = Math.max(0, Number(data.timer.duration) - elapsedSec);
            } else {
                serverTimeLeft = Number(data.timer.time_left);
            }
            
            updateTimerDisplay();
            
            // Starte lokalen Countdown nur wenn Timer l√§uft und Zeit > 0
            stopLocalCountdown();
            if (data.timer.timer_running && serverTimeLeft > 0) {
                startLocalCountdown();
            }
        }
        
        // Submitted count aktualisieren
        if (typeof data.submitted_count !== 'undefined') {
            const submittedNumber = document.getElementById('submittedNumber');
            const totalPlayersEl = document.getElementById('totalPlayers');
            
            if (submittedNumber) submittedNumber.textContent = data.submitted_count;
            if (totalPlayersEl) totalPlayersEl.textContent = data.total_players;
        }
    });

    socket.on('contribution_submitted', function(data) {
        const submittedNumber = document.getElementById('submittedNumber');
        const totalPlayersEl = document.getElementById('totalPlayers');

        if (submittedNumber) {
            submittedNumber.textContent = data.submitted_count;
        }
        if (totalPlayersEl) {
            totalPlayersEl.textContent = data.total_players;
        }
    });

    let lastServerUpdate = Date.now();
    const SYNC_THRESHOLD = 2000; // 2 Sekunden

    socket.on('game_timer_update', function(data) {
        lastServerUpdate = Date.now();
        
        // Server ist authoritative
        if (data.start_time && data.duration) {
            const nowMs = Date.now();
            const elapsedSec = Math.floor((nowMs - Number(data.start_time)) / 1000);
            serverTimeLeft = Math.max(0, Number(data.duration) - elapsedSec);
        } else if (typeof data.time_left !== 'undefined') {
            serverTimeLeft = Number(data.time_left);
        }

        updateTimerDisplay();
        
        // Resette lokalen Countdown und starte neu mit Server-Wert
        stopLocalCountdown();
        if (serverTimeLeft > 0) {
            startLocalCountdown();
        }
    });

    socket.on('game_time_out', function() {
        console.log('DEBUG: game_time_out received');
        showNotification('Zeit abgelaufen! Beitr√§ge werden automatisch eingereicht.', 'warning');

        // Server hat Timeout ‚Äì sichere clientseitige Auto-Submit
        stopLocalCountdown();
        handleTimeExpiredOnce();
    });

    socket.on('round_finished', function(data) {
        console.log('DEBUG: round_finished received, redirecting to round results');
        showNotification('Runde beendet! Zeige Ergebnisse...', 'success');
        // kleine Verz√∂gerung damit UI Meldung wahrnehmbar ist
        setTimeout(() => {
            window.location.href = `/round_results/${data.room_id}`;
        }, 800);
    });

    socket.on('redirect_to_results', function(data) {
        console.log('DEBUG: redirect_to_results received');
        showNotification('Runde beendet! Zeige Ergebnisse...', 'success');
        setTimeout(() => {
            window.location.href = `/round_results/${data.room_id}`;
        }, 600);
    });

    socket.on('game_finished', function(data) {
        showNotification('Spiel beendet! Zeige Auswertung...', 'success');
        setTimeout(() => {
            window.location.href = `/evaluation/${data.room_id}`;
        }, 800);
    });
</script>
{% endblock %}